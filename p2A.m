function [A, varargout] = p2A(p, varargin)
%P2A Convert orientation vectors to an orientation tensor.
%   A = P2A(P) gives the second-order orientation tensor A for the set of
%   orientation vectors P. For 3-D vectors P is 3xN, with P(I,J) giving the
%   Ith Cartesian component of vector J.  The resulting A is 3x3.  If P is
%   2xN then the vectors are 2-D and A is 2x2.
%
%   A = P2A(P, W) weights each vector P(:,J) with the weighting factor
%   W(J). 
%
%[A, A4] = P2A(P) also returns the fourth-order orientation tensor A4,
%   in 6x6 matrix form for 3-D and in 3x3 matrix form 2-D.

% -- Determine whether the p vectors are 2-D or 3-D
[d, nump] = size(p);  % d is the dimensionality of the problem, 2 or 3
if d < 2 || d > 3
    error('P must be 3xN or 2xN')
end

% -- Set up the weighting factors w as a row vector
if nargin > 1
    % Use the second argument as the weighting factors
    w = varargin{1};
    [wrows, ~] = size(w);
    if wrows > 1, w = w'; end   % Make sure w is a row vector
else
    w = ones(1, nump);  % The default is equal weigthing
end
w = w / sum(w);  % Normalize the weights

% -- Second-order tensor
%    Each column of pp has the tensor pp for one p vector in tens2vec form
if d == 2
    pp = [p(1,:) .* p(1,:); ...
          p(2,:) .* p(2,:); ...
          p(1,:) .* p(2,:)]; 
else
    pp = [p(1,:) .* p(1,:); ...
          p(2,:) .* p(2,:); ...
          p(3,:) .* p(3,:); ...
          p(2,:) .* p(3,:); ...
          p(3,:) .* p(1,:); ...
          p(1,:) .* p(2,:)]; 
end
A = vec2tens( pp * w');

if nargout >= 2
    % Also calculate the fourth-order tensor
    % Each column of p4 has the tensor pppp for one p vector 
    % in tens2vec4 form
    if d == 2
        p4 = [p(1,:).^4             ; ...
              p(2,:).^4             ; ...
              p(1,:).^2 .* p(2,:).^2; ...
              p(1,:).^3 .* p(2,:)   ; ...
              p(1,:)    .* p(2,:).^3];
    else
        p4 = [p(1,:).^4                    ; ...
              p(2,:).^4                    ; ...
              p(3,:).^4                    ; ...
              p(2,:).^2 .* p(3,:).^2       ; ...
              p(3,:).^2 .* p(1,:).^2       ; ...
              p(1,:).^2 .* p(2,:).^2       ; ...
              p(1,:).^2 .* p(2,:) .* p(3,:); ...
              p(1,:).^3 .* p(3,:)          ; ...
              p(1,:).^3 .* p(2,:)          ; ...
              p(2,:).^3 .* p(3,:)          ; ...
              p(2,:).^2 .* p(3,:) .* p(1,:); ...
              p(2,:).^3 .* p(1,:)          ; ...
              p(3,:).^3 .* p(2,:)          ; ...
              p(3,:).^3 .* p(1,:)          ; ...
              p(3,:).^2 .* p(1,:) .* p(2,:)]; 
    end
    A4 = vec2tens4( p4 * w');
    varargout{1} = A4;
end
    
return